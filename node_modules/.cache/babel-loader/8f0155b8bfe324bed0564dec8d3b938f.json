{"ast":null,"code":"import * as util from './readline.js';\nimport cliWidth from 'cli-width';\nimport wrapAnsi from 'wrap-ansi';\nimport stripAnsi from 'strip-ansi';\nimport stringWidth from 'string-width';\nimport ora from 'ora';\n\nfunction height(content) {\n  return content.split('\\n').length;\n}\n/** @param {string} content */\n\n\nfunction lastLine(content) {\n  return content.split('\\n').pop();\n}\n\nexport default class ScreenManager {\n  constructor(rl) {\n    // These variables are keeping information to allow correct prompt re-rendering\n    this.height = 0;\n    this.extraLinesUnderPrompt = 0;\n    this.rl = rl;\n  }\n\n  renderWithSpinner(content, bottomContent) {\n    if (this.spinnerId) {\n      clearInterval(this.spinnerId);\n    }\n\n    let spinner;\n    let contentFunc;\n    let bottomContentFunc;\n\n    if (bottomContent) {\n      spinner = ora(bottomContent);\n\n      contentFunc = () => content;\n\n      bottomContentFunc = () => spinner.frame();\n    } else {\n      spinner = ora(content);\n\n      contentFunc = () => spinner.frame();\n\n      bottomContentFunc = () => '';\n    }\n\n    this.spinnerId = setInterval(() => this.render(contentFunc(), bottomContentFunc(), true), spinner.interval);\n  }\n\n  render(content, bottomContent) {\n    let spinning = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n    if (this.spinnerId && !spinning) {\n      clearInterval(this.spinnerId);\n    }\n\n    this.rl.output.unmute();\n    this.clean(this.extraLinesUnderPrompt);\n    /**\n     * Write message to screen and setPrompt to control backspace\n     */\n\n    const promptLine = lastLine(content);\n    const rawPromptLine = stripAnsi(promptLine); // Remove the rl.line from our prompt. We can't rely on the content of\n    // rl.line (mainly because of the password prompt), so just rely on it's\n    // length.\n\n    let prompt = rawPromptLine;\n\n    if (this.rl.line.length) {\n      prompt = prompt.slice(0, -this.rl.line.length);\n    }\n\n    this.rl.setPrompt(prompt); // SetPrompt will change cursor position, now we can get correct value\n\n    const cursorPos = this.rl._getCursorPos();\n\n    const width = this.normalizedCliWidth();\n    content = this.forceLineReturn(content, width);\n\n    if (bottomContent) {\n      bottomContent = this.forceLineReturn(bottomContent, width);\n    } // Manually insert an extra line if we're at the end of the line.\n    // This prevent the cursor from appearing at the beginning of the\n    // current line.\n\n\n    if (rawPromptLine.length % width === 0) {\n      content += '\\n';\n    }\n\n    const fullContent = content + (bottomContent ? '\\n' + bottomContent : '');\n    this.rl.output.write(fullContent);\n    /**\n     * Re-adjust the cursor at the correct position.\n     */\n    // We need to consider parts of the prompt under the cursor as part of the bottom\n    // content in order to correctly cleanup and re-render.\n\n    const promptLineUpDiff = Math.floor(rawPromptLine.length / width) - cursorPos.rows;\n    const bottomContentHeight = promptLineUpDiff + (bottomContent ? height(bottomContent) : 0);\n\n    if (bottomContentHeight > 0) {\n      util.up(this.rl, bottomContentHeight);\n    } // Reset cursor at the beginning of the line\n\n\n    util.left(this.rl, stringWidth(lastLine(fullContent))); // Adjust cursor on the right\n\n    if (cursorPos.cols > 0) {\n      util.right(this.rl, cursorPos.cols);\n    }\n    /**\n     * Set up state for next re-rendering\n     */\n\n\n    this.extraLinesUnderPrompt = bottomContentHeight;\n    this.height = height(fullContent);\n    this.rl.output.mute();\n  }\n\n  clean(extraLines) {\n    if (extraLines > 0) {\n      util.down(this.rl, extraLines);\n    }\n\n    util.clearLine(this.rl, this.height);\n  }\n\n  done() {\n    this.rl.setPrompt('');\n    this.rl.output.unmute();\n    this.rl.output.write('\\n');\n  }\n\n  releaseCursor() {\n    if (this.extraLinesUnderPrompt > 0) {\n      util.down(this.rl, this.extraLinesUnderPrompt);\n    }\n  }\n\n  normalizedCliWidth() {\n    const width = cliWidth({\n      defaultWidth: 80,\n      output: this.rl.output\n    });\n    return width;\n  }\n  /**\n   * @param {string[]} lines\n   */\n\n\n  breakLines(lines) {\n    let width = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.normalizedCliWidth();\n    // Break lines who're longer than the cli width so we can normalize the natural line\n    // returns behavior across terminals.\n    // re: trim: false; by default, `wrap-ansi` trims whitespace, which\n    // is not what we want.\n    // re: hard: true; by default', `wrap-ansi` does soft wrapping\n    return lines.map(line => wrapAnsi(line, width, {\n      trim: false,\n      hard: true\n    }).split('\\n'));\n  }\n  /**\n   * @param {string} content\n   */\n\n\n  forceLineReturn(content) {\n    let width = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.normalizedCliWidth();\n    return this.breakLines(content.split('\\n'), width).flat().join('\\n');\n  }\n\n}","map":{"version":3,"names":["util","cliWidth","wrapAnsi","stripAnsi","stringWidth","ora","height","content","split","length","lastLine","pop","ScreenManager","constructor","rl","extraLinesUnderPrompt","renderWithSpinner","bottomContent","spinnerId","clearInterval","spinner","contentFunc","bottomContentFunc","frame","setInterval","render","interval","spinning","output","unmute","clean","promptLine","rawPromptLine","prompt","line","slice","setPrompt","cursorPos","_getCursorPos","width","normalizedCliWidth","forceLineReturn","fullContent","write","promptLineUpDiff","Math","floor","rows","bottomContentHeight","up","left","cols","right","mute","extraLines","down","clearLine","done","releaseCursor","defaultWidth","breakLines","lines","map","trim","hard","flat","join"],"sources":["/home/razma/node_modules/inquirer/lib/utils/screen-manager.js"],"sourcesContent":["import * as util from './readline.js';\nimport cliWidth from 'cli-width';\nimport wrapAnsi from 'wrap-ansi';\nimport stripAnsi from 'strip-ansi';\nimport stringWidth from 'string-width';\nimport ora from 'ora';\n\nfunction height(content) {\n  return content.split('\\n').length;\n}\n\n/** @param {string} content */\nfunction lastLine(content) {\n  return content.split('\\n').pop();\n}\n\nexport default class ScreenManager {\n  constructor(rl) {\n    // These variables are keeping information to allow correct prompt re-rendering\n    this.height = 0;\n    this.extraLinesUnderPrompt = 0;\n\n    this.rl = rl;\n  }\n\n  renderWithSpinner(content, bottomContent) {\n    if (this.spinnerId) {\n      clearInterval(this.spinnerId);\n    }\n\n    let spinner;\n    let contentFunc;\n    let bottomContentFunc;\n\n    if (bottomContent) {\n      spinner = ora(bottomContent);\n      contentFunc = () => content;\n      bottomContentFunc = () => spinner.frame();\n    } else {\n      spinner = ora(content);\n      contentFunc = () => spinner.frame();\n      bottomContentFunc = () => '';\n    }\n\n    this.spinnerId = setInterval(\n      () => this.render(contentFunc(), bottomContentFunc(), true),\n      spinner.interval\n    );\n  }\n\n  render(content, bottomContent, spinning = false) {\n    if (this.spinnerId && !spinning) {\n      clearInterval(this.spinnerId);\n    }\n\n    this.rl.output.unmute();\n    this.clean(this.extraLinesUnderPrompt);\n\n    /**\n     * Write message to screen and setPrompt to control backspace\n     */\n\n    const promptLine = lastLine(content);\n    const rawPromptLine = stripAnsi(promptLine);\n\n    // Remove the rl.line from our prompt. We can't rely on the content of\n    // rl.line (mainly because of the password prompt), so just rely on it's\n    // length.\n    let prompt = rawPromptLine;\n    if (this.rl.line.length) {\n      prompt = prompt.slice(0, -this.rl.line.length);\n    }\n\n    this.rl.setPrompt(prompt);\n\n    // SetPrompt will change cursor position, now we can get correct value\n    const cursorPos = this.rl._getCursorPos();\n    const width = this.normalizedCliWidth();\n\n    content = this.forceLineReturn(content, width);\n    if (bottomContent) {\n      bottomContent = this.forceLineReturn(bottomContent, width);\n    }\n\n    // Manually insert an extra line if we're at the end of the line.\n    // This prevent the cursor from appearing at the beginning of the\n    // current line.\n    if (rawPromptLine.length % width === 0) {\n      content += '\\n';\n    }\n\n    const fullContent = content + (bottomContent ? '\\n' + bottomContent : '');\n    this.rl.output.write(fullContent);\n\n    /**\n     * Re-adjust the cursor at the correct position.\n     */\n\n    // We need to consider parts of the prompt under the cursor as part of the bottom\n    // content in order to correctly cleanup and re-render.\n    const promptLineUpDiff = Math.floor(rawPromptLine.length / width) - cursorPos.rows;\n    const bottomContentHeight =\n      promptLineUpDiff + (bottomContent ? height(bottomContent) : 0);\n    if (bottomContentHeight > 0) {\n      util.up(this.rl, bottomContentHeight);\n    }\n\n    // Reset cursor at the beginning of the line\n    util.left(this.rl, stringWidth(lastLine(fullContent)));\n\n    // Adjust cursor on the right\n    if (cursorPos.cols > 0) {\n      util.right(this.rl, cursorPos.cols);\n    }\n\n    /**\n     * Set up state for next re-rendering\n     */\n    this.extraLinesUnderPrompt = bottomContentHeight;\n    this.height = height(fullContent);\n\n    this.rl.output.mute();\n  }\n\n  clean(extraLines) {\n    if (extraLines > 0) {\n      util.down(this.rl, extraLines);\n    }\n\n    util.clearLine(this.rl, this.height);\n  }\n\n  done() {\n    this.rl.setPrompt('');\n    this.rl.output.unmute();\n    this.rl.output.write('\\n');\n  }\n\n  releaseCursor() {\n    if (this.extraLinesUnderPrompt > 0) {\n      util.down(this.rl, this.extraLinesUnderPrompt);\n    }\n  }\n\n  normalizedCliWidth() {\n    const width = cliWidth({\n      defaultWidth: 80,\n      output: this.rl.output,\n    });\n    return width;\n  }\n\n  /**\n   * @param {string[]} lines\n   */\n  breakLines(lines, width = this.normalizedCliWidth()) {\n    // Break lines who're longer than the cli width so we can normalize the natural line\n    // returns behavior across terminals.\n    // re: trim: false; by default, `wrap-ansi` trims whitespace, which\n    // is not what we want.\n    // re: hard: true; by default', `wrap-ansi` does soft wrapping\n    return lines.map((line) =>\n      wrapAnsi(line, width, { trim: false, hard: true }).split('\\n')\n    );\n  }\n\n  /**\n   * @param {string} content\n   */\n  forceLineReturn(content, width = this.normalizedCliWidth()) {\n    return this.breakLines(content.split('\\n'), width).flat().join('\\n');\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}