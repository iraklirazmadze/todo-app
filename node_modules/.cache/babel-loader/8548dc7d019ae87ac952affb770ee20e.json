{"ast":null,"code":"import chalk from 'chalk';\n/**\n * The paginator returns a subset of the choices if the list is too long.\n */\n\nexport default class Paginator {\n  /**\n   * @param {import(\"./screen-manager\")} [screen]\n   * @param {{isInfinite?: boolean}} [options]\n   */\n  constructor(screen) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const {\n      isInfinite = true\n    } = options;\n    this.lastIndex = 0;\n    this.screen = screen;\n    this.isInfinite = isInfinite;\n  }\n\n  paginate(output, active, pageSize) {\n    pageSize = pageSize || 7;\n    let lines = output.split('\\n');\n\n    if (this.screen) {\n      lines = this.screen.breakLines(lines);\n      active = lines.map(lineParts => lineParts.length).splice(0, active).reduce((a, b) => a + b, 0);\n      lines = lines.flat();\n    } // Make sure there's enough lines to paginate\n\n\n    if (lines.length <= pageSize) {\n      return output;\n    }\n\n    const visibleLines = this.isInfinite ? this.getInfiniteLines(lines, active, pageSize) : this.getFiniteLines(lines, active, pageSize);\n    this.lastIndex = active;\n    return visibleLines.join('\\n') + '\\n' + chalk.dim('(Move up and down to reveal more choices)');\n  }\n\n  getInfiniteLines(lines, active, pageSize) {\n    if (this.pointer === undefined) {\n      this.pointer = 0;\n    }\n\n    const middleOfList = Math.floor(pageSize / 2); // Move the pointer only when the user go down and limit it to the middle of the list\n\n    if (this.pointer < middleOfList && this.lastIndex < active && active - this.lastIndex < pageSize) {\n      this.pointer = Math.min(middleOfList, this.pointer + active - this.lastIndex);\n    } // Duplicate the lines so it give an infinite list look\n\n\n    const infinite = [lines, lines, lines].flat();\n    const topIndex = Math.max(0, active + lines.length - this.pointer);\n    return infinite.splice(topIndex, pageSize);\n  }\n\n  getFiniteLines(lines, active, pageSize) {\n    let topIndex = active - pageSize / 2;\n\n    if (topIndex < 0) {\n      topIndex = 0;\n    } else if (topIndex + pageSize > lines.length) {\n      topIndex = lines.length - pageSize;\n    }\n\n    return lines.splice(topIndex, pageSize);\n  }\n\n}","map":{"version":3,"names":["chalk","Paginator","constructor","screen","options","isInfinite","lastIndex","paginate","output","active","pageSize","lines","split","breakLines","map","lineParts","length","splice","reduce","a","b","flat","visibleLines","getInfiniteLines","getFiniteLines","join","dim","pointer","undefined","middleOfList","Math","floor","min","infinite","topIndex","max"],"sources":["/home/razma/node_modules/inquirer/lib/utils/paginator.js"],"sourcesContent":["import chalk from 'chalk';\n\n/**\n * The paginator returns a subset of the choices if the list is too long.\n */\n\nexport default class Paginator {\n  /**\n   * @param {import(\"./screen-manager\")} [screen]\n   * @param {{isInfinite?: boolean}} [options]\n   */\n  constructor(screen, options = {}) {\n    const { isInfinite = true } = options;\n    this.lastIndex = 0;\n    this.screen = screen;\n    this.isInfinite = isInfinite;\n  }\n\n  paginate(output, active, pageSize) {\n    pageSize = pageSize || 7;\n    let lines = output.split('\\n');\n\n    if (this.screen) {\n      lines = this.screen.breakLines(lines);\n      active = lines\n        .map((lineParts) => lineParts.length)\n        .splice(0, active)\n        .reduce((a, b) => a + b, 0);\n      lines = lines.flat();\n    }\n\n    // Make sure there's enough lines to paginate\n    if (lines.length <= pageSize) {\n      return output;\n    }\n    const visibleLines = this.isInfinite\n      ? this.getInfiniteLines(lines, active, pageSize)\n      : this.getFiniteLines(lines, active, pageSize);\n    this.lastIndex = active;\n    return (\n      visibleLines.join('\\n') +\n      '\\n' +\n      chalk.dim('(Move up and down to reveal more choices)')\n    );\n  }\n\n  getInfiniteLines(lines, active, pageSize) {\n    if (this.pointer === undefined) {\n      this.pointer = 0;\n    }\n    const middleOfList = Math.floor(pageSize / 2);\n    // Move the pointer only when the user go down and limit it to the middle of the list\n    if (\n      this.pointer < middleOfList &&\n      this.lastIndex < active &&\n      active - this.lastIndex < pageSize\n    ) {\n      this.pointer = Math.min(middleOfList, this.pointer + active - this.lastIndex);\n    }\n\n    // Duplicate the lines so it give an infinite list look\n    const infinite = [lines, lines, lines].flat();\n    const topIndex = Math.max(0, active + lines.length - this.pointer);\n\n    return infinite.splice(topIndex, pageSize);\n  }\n\n  getFiniteLines(lines, active, pageSize) {\n    let topIndex = active - pageSize / 2;\n    if (topIndex < 0) {\n      topIndex = 0;\n    } else if (topIndex + pageSize > lines.length) {\n      topIndex = lines.length - pageSize;\n    }\n    return lines.splice(topIndex, pageSize);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}